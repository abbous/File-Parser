
module.exports=recAccParser;

var
  fs=require('fs')
;

function smallestOfExcept()
{
    var smallest=null;
    var except=arguments[arguments.length-1];
    for(var i=0; i<arguments.length-2; ++i)
    {
      if(arguments[i]==except)
        continue;
      if(arguments[i]<smallest || smallest==null)
        smallest=arguments[i];
    }
    return smallest;
}

function isspace(c)
{
  return c==' '||c=='\t'||c=='\n'||c=='\r';
}

function isquote(c)
{
  return c=='\''||c=='"';
}

function getNodeInfo(text) // <doc a='a' b='b'>
{
  var parsing=null;
  var name='';
  var attrs={};
  var aname='', aval='';
  for(var i=0; i<text.length; ++i)
  {
    var c=text.charAt(i);
    if(c=='<' && parsing==null)
    {
      parsing='post-open-tag';
      continue;
    }
    else if(isspace(c) && parsing=='post-open-tag')
    {
      continue;
    }
    else if(!isspace(c) && c!='>' && parsing=='post-open-tag')
    {
      name+=c;
      parsing='tag';
      continue;
    }
    else if(!isspace(c) && c!='>'  && c!='/' && parsing=='tag')
    {
      name+=c;
      continue;
    }
    else if((c=='/'||c=='>') && parsing=='tag')
    {
      parsing='free-space';
      continue;
    }
    else if(isspace(c) && parsing=='free-space')
      continue;
    else if(c=='>' && parsing=='tag')
    {
      parsing='free-space';
      continue;
    }
    else if(isspace(c) && parsing=='tag')
    {
      parsing='free-space';
      continue;
    }
    else if(!isspace(c) && c!='>' && parsing=='free-space')
    {
      parsing='aname';
      aname=c;
      continue;
    }
    else if(!isspace(c) && c!='=' && parsing=='aname')
    {
      parsing='aname';
      aname+=c;
      continue;
    }
    else if(parsing=='aname' && c=='=')
    {
      parsing='post-aname';
      continue;
    }
    else if(parsing=='post-aname' && !isspace(c) && isquote(c))
    {
      parsing='aval';
      aval='';
      continue;
    }
    else if(parsing=='aval' && !isquote(c))
    {
      aval+=c;
      continue;
    }
    else if(parsing=='aval' && isquote(c))
    {
      attrs[aname]=aval;
      parsing='free-space';
      continue;
    }
    else if( (parsing=='free-space') && c=='>')
    {
      continue;
    }
    else {
      console.log("What's "+c+" while parsing "+parsing);
    }
  }
  return {
    name: name,
    attrs: attrs
  };
}

function lowLevelParser(filename)
{
  var readable = fs.createReadStream(filename, {
      encoding: 'utf8',
      fd: null,
  });

  var lastChar=null;
  var state=null;
  var text='';

  readable.on('close', function() {
    readable.emit('endDocument');
  });
  readable.on('open', function() {
    readable.emit('startDocument');
  });
  readable.on('readable', function() {
    var chunk;
    while (null !== (chunk = readable.read(1)))
    {
      //console.log(state+": "+state+", str="+text);
      if(chunk=='<' && state!='in-tag')
      {
        if(text!='' && !text.match(/^[\W]+$/))
          readable.emit('text', text);
        state='in-tag';
        text='<';
        continue;
      }
      else if(chunk=='>' && state=='in-tag')
      {
        text+='>';
        if(text.charAt(1)=='/')
          readable.emit('endElement', text.substr(2, text.length-3));
        else {
          var nodeInfo=getNodeInfo(text);
          if(text.charAt(text.length-2)=='/')
            readable.emit('startEndElement', nodeInfo.name, nodeInfo.attrs);
          else
            readable.emit('startElement', nodeInfo.name, nodeInfo.attrs);
        }
        text='';
        state='out-tag';
        continue;
      }
      else
        text+=chunk;
      lastChar=chunk;
    }
  });
  return readable;
}

function genWriter(filename, options)
{
  var ws=fs.createWriteStream(filename);
  var n=0;

  return {
    write: function(err, rec) {
      if(options.format=='json')
      {
        if(n!=0)
          ws.write(',\n');
        ws.write(JSON.stringify(rec));
      }
      else
      {
        ws.write(rec);
        ws.write('\n');
      }
      ++n;
    },
    close: function() {
      ws.close();
    }
  };
}
/**
   default options
   options.preserveWhiteSpaces=false;
   options.format='csv'; // csv|json
   options.heading=false;
*/
function recAccParser(filename, recordElements, options, cb)
{
  var n=0;

  if(typeof(recordElements)!='Array')
    recordElements=[recordElements];

  if(typeof(options)!='object')
  {
    cb=options;
    options={};
  }

  if(typeof(cb)=='string')
  {
    var output=cb;
    if(!options.format)
    {
      if(output.match(/.json$/))
        options.format='json';
      if(output.match(/.csv$/))
      {
        options.format='csv';
        if(!options.heading)
          options.heading=true;
      }
      if(output.match(/.tsv$/))
      {
        options.format='tsv';
        if(!options.heading)
          options.heading=true;
      }
    }
    var writer=genWriter(output, options);
    cb=writer.write;
  }

  var json={};
  var elementStack=[];
  var elementOrder=[];
  var textStack=[];
  options.seperator=options.seperator||',';

  var parser = lowLevelParser(filename)
  .on('startElement', function(name, attrs) {
    if(-1!=recordElements.indexOf(name))
    {
      json={};
      elementStack=[];
      elementOrder=[];
      textStack=[];
    }
    else
    {
      elementStack.push(name);
      textStack.push('');
      elementOrder.push(name);
    }
  })
  .on('endElement', function(name) {
    if(-1!=recordElements.indexOf(name))
    {
      if(options.format=='json')
        cb(null, json);
      else {
        var values=[];
        elementOrder.forEach(function(name) {
          values.push(json[name]);
        });
        if(n==0 && options.heading)
          cb(null, elementOrder.join(options.seperator));
        ++n;
        cb(null, values.join(options.seperator));
      }
    }
    else {
      const text=textStack.pop();
      if(text)
      {
        json[elementStack.join('.')]=options.preserveWhiteSpaces?
          text:text.replace(/^[\r\n\t ]+$/, '');
      }
      elementStack.pop();
    }
  })
  .on('text', function(text) {
    textStack[textStack.length-1]+=text;
  })
  .on('error', function(error) {
    cb(error);
  })
  .on('endDocument', function() {
    if(writer)
      writer.close();
  });
}

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const parser_1 = require("../parser");
describe('parser type object', () => {
    test('ignore rows if element length is less than keys length', () => __awaiter(this, void 0, void 0, function* () {
        const input = `a,b,c
true,false,3

`;
        expect(parser_1.parser(input)).toEqual([
            {
                a: true,
                b: false,
                c: 3
            }
        ]);
    }));
    test('parse boolean string to boolean', () => __awaiter(this, void 0, void 0, function* () {
        const input = `a,b,c
true,false,3`;
        expect(parser_1.parser(input)).toEqual([
            {
                a: true,
                b: false,
                c: 3
            }
        ]);
    }));
    test('parse null or undefined string to null or undefined', () => __awaiter(this, void 0, void 0, function* () {
        const input = `a,b,c
null, undefined, 3`;
        expect(parser_1.parser(input)).toEqual([
            {
                a: null,
                b: undefined,
                c: 3
            }
        ]);
    }));
    test('return empty array when first parameter is ""', () => __awaiter(this, void 0, void 0, function* () {
        const input = ``;
        expect(parser_1.parser(input)).toEqual([]);
    }));
    test('trim space and tab before and after string', () => __awaiter(this, void 0, void 0, function* () {
        const input = `a, b,   c
1	,2 , 3 2`;
        expect(parser_1.parser(input, {
            trim: true
        })).toEqual([
            {
                a: 1,
                b: 2,
                c: '3 2'
            }
        ]);
    }));
    describe('parser using tab for separator', () => {
        test('parse tsv to object', () => __awaiter(this, void 0, void 0, function* () {
            const input = `a	b	c
1	2	3`;
            expect(parser_1.parser(input, {
                separator: '\t',
                trim: false
            })).toEqual([
                {
                    a: 1,
                    b: 2,
                    c: 3
                }
            ]);
        }));
    });
    describe('parser using trim option', () => {
        test('should not trim space and tab before and after string', () => __awaiter(this, void 0, void 0, function* () {
            const input = `a, b,   c
1	,2 , 3 2`;
            expect(parser_1.parser(input, {
                trim: false,
                convertNumber: false
            })).toEqual([
                {
                    a: '1	',
                    ' b': '2 ',
                    '   c': ' 3 2'
                }
            ]);
        }));
    });
    describe('parser using parseNumber option', () => {
        test('should not parse number value to Number', () => __awaiter(this, void 0, void 0, function* () {
            const input = `a, b, c
1, 2, 3`;
            expect(parser_1.parser(input, {
                convertNumber: false
            })).toEqual([
                {
                    a: '1',
                    b: '2',
                    c: '3'
                }
            ]);
        }));
    });
    describe('parser using parseBoolean option', () => {
        test('should not convert boolean value to boolean', () => __awaiter(this, void 0, void 0, function* () {
            const input = `a, b, c
1, true, false`;
            expect(parser_1.parser(input, {
                convertBoolean: false
            })).toEqual([
                {
                    a: 1,
                    b: 'true',
                    c: 'false'
                }
            ]);
        }));
    });
    describe('parser using keys option', () => {
        test('use keys option for key insteadof firstline', () => __awaiter(this, void 0, void 0, function* () {
            const input = `a, b, c
1, true, false`;
            expect(parser_1.parser(input, {
                keys: ['aaa', 'bbb', 'ccc']
            })).toEqual([
                {
                    aaa: 'a',
                    bbb: 'b',
                    ccc: 'c'
                },
                {
                    aaa: 1,
                    bbb: true,
                    ccc: false
                }
            ]);
        }));
    });
    describe('parser using default option', () => {
        test('return default value if value is null or undefined', () => __awaiter(this, void 0, void 0, function* () {
            const input = `a, b, c
, true, 1
2, , 3
4, 5,`;
            expect(parser_1.parser(input, {
                defaultValue: 'default value'
            })).toEqual([
                { a: 'default value', b: true, c: 1 },
                { a: 2, b: 'default value', c: 3 },
                { a: 4, b: 5, c: 'default value' }
            ]);
        }));
    });
    describe('parser using startRow option', () => {
        test('return row from start row', () => __awaiter(this, void 0, void 0, function* () {
            const input = `a, b, c
A, B, C
1, 2, 3`;
            expect(parser_1.parser(input, {
                startRow: 1
            })).toEqual([{ A: 1, B: 2, C: 3 }]);
        }));
    });
    describe('parser using startColumn option', () => {
        test('row has columns from start column', () => __awaiter(this, void 0, void 0, function* () {
            const input = `a, b, c
1, 2, 3`;
            expect(parser_1.parser(input, {
                startColumn: 1
            })).toEqual([{ b: 2, c: 3 }]);
        }));
    });
    describe('parser using startColumn and StartRow option', () => {
        test('return row from start row that has columns from start column', () => __awaiter(this, void 0, void 0, function* () {
            const input = `a, b, c
A, B, C
4, 5 ,6`;
            expect(parser_1.parser(input, {
                startColumn: 1,
                startRow: 1
            })).toEqual([{ B: 5, C: 6 }]);
        }));
    });
    describe('parser using numberOfColumn', () => {
        test("row's number of column is less than number Of Column", () => __awaiter(this, void 0, void 0, function* () {
            const input = `a, b, c
1, 2 ,3`;
            expect(parser_1.parser(input, {
                numberOfColumn: 2
            })).toEqual([{ a: 1, b: 2 }]);
        }));
    });
    describe('parser using ignoreRow.emptyRow', () => {
        test('ignore rows have every element is defaultValue', () => __awaiter(this, void 0, void 0, function* () {
            const input = `a	b	c	d
      1	2		3	4	
      					`;
            expect(parser_1.parser(input, {
                separator: '\t',
                startColumn: 0,
                numberOfColumn: 4,
                defaultValue: null,
                ignoreRow: {
                    emptyRow: true
                }
            })).toEqual([{ a: 1, b: 2, c: null, d: 3 }]);
        }));
    });
});

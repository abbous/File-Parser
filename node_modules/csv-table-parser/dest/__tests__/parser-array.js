"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const parser_1 = require("../parser");
describe('parser type array', () => {
    const defaultOptions = { type: 'array' };
    test('ignore rows if element length is less than first element length', () => __awaiter(this, void 0, void 0, function* () {
        const input = `a,b,c
1, true,false

`;
        expect(parser_1.parser(input, defaultOptions)).toEqual([['a', 'b', 'c'], [1, true, false]]);
    }));
    test('parse csv to array', () => __awaiter(this, void 0, void 0, function* () {
        const input = `a, b, c
1, true, false`;
        expect(parser_1.parser(input, defaultOptions)).toEqual([['a', 'b', 'c'], [1, true, false]]);
    }));
    test('parse null or undefined string to null or undefined', () => __awaiter(this, void 0, void 0, function* () {
        const input = `a,b,c
null, undefined, 3`;
        expect(parser_1.parser(input, defaultOptions)).toEqual([['a', 'b', 'c'], [null, undefined, 3]]);
    }));
    describe('parser using tab for separator', () => {
        test('parse tsv to array', () => __awaiter(this, void 0, void 0, function* () {
            const input = `a	b	c
1	2	3`;
            expect(parser_1.parser(input, Object.assign({}, defaultOptions, { separator: '\t', trim: false }))).toEqual([['a', 'b', 'c'], [1, 2, 3]]);
        }));
    });
    describe('parser using trim option', () => {
        test('should not trim space and tab before and after string', () => __awaiter(this, void 0, void 0, function* () {
            const input = `a, b,   c
1	,2 , 3 2`;
            expect(parser_1.parser(input, Object.assign({}, defaultOptions, { trim: false, convertNumber: false }))).toEqual([['a', ' b', '   c'], ['1	', '2 ', ' 3 2']]);
        }));
    });
    describe('parser using parseNumber option', () => {
        test('should not parse number value to Number', () => __awaiter(this, void 0, void 0, function* () {
            const input = `a, b, c
1, 2, 3`;
            expect(parser_1.parser(input, Object.assign({}, defaultOptions, { convertNumber: false }))).toEqual([['a', 'b', 'c'], ['1', '2', '3']]);
        }));
    });
    describe('parser using parseBoolean option', () => {
        test('should not convert boolean value to boolean', () => __awaiter(this, void 0, void 0, function* () {
            const input = `a, b, c
1, true, false`;
            expect(parser_1.parser(input, Object.assign({}, defaultOptions, { convertBoolean: false }))).toEqual([['a', 'b', 'c'], [1, 'true', 'false']]);
        }));
    });
    describe('parser using keys option', () => {
        test('ignore keys option', () => __awaiter(this, void 0, void 0, function* () {
            const input = `a, b, c
1, true, false`;
            expect(parser_1.parser(input, Object.assign({}, defaultOptions, { keys: ['aaa', 'bbb', 'ccc'] }))).toEqual([['a', 'b', 'c'], [1, true, false]]);
        }));
    });
    describe('parser using default option', () => {
        test('return default value if value is null or undefined', () => __awaiter(this, void 0, void 0, function* () {
            const input = `a, b, c
, true, 1
2, , 3
4, 5,`;
            expect(parser_1.parser(input, Object.assign({}, defaultOptions, { defaultValue: 'default value' }))).toEqual([['a', 'b', 'c'], ['default value', true, 1], [2, 'default value', 3], [4, 5, 'default value']]);
        }));
    });
    describe('parser using startRow option', () => {
        test('return row from start row', () => __awaiter(this, void 0, void 0, function* () {
            const input = `a, b, c
1, 2, 3`;
            expect(parser_1.parser(input, Object.assign({}, defaultOptions, { startRow: 1 }))).toEqual([[1, 2, 3]]);
        }));
    });
    describe('parser using startColumn option', () => {
        test('row has columns from start column', () => __awaiter(this, void 0, void 0, function* () {
            const input = `a, b, c
1, 2, 3`;
            expect(parser_1.parser(input, Object.assign({}, defaultOptions, { startColumn: 1 }))).toEqual([['b', 'c'], [2, 3]]);
        }));
    });
    describe('parser using startColumn and StartRow option', () => {
        test('return row from start row that has columns from start column', () => __awaiter(this, void 0, void 0, function* () {
            const input = `a, b, c
A, B, C
4, 5 ,6`;
            expect(parser_1.parser(input, Object.assign({}, defaultOptions, { startColumn: 1, startRow: 1 }))).toEqual([['B', 'C'], [5, 6]]);
        }));
    });
    describe('parser using numberOfColumn', () => {
        test("row's number of column is less than number Of Column", () => __awaiter(this, void 0, void 0, function* () {
            const input = `a, b, c
1, 2 ,3`;
            expect(parser_1.parser(input, Object.assign({}, defaultOptions, { numberOfColumn: 2 }))).toEqual([['a', 'b'], [1, 2]]);
        }));
    });
    describe('parser using ignoreRow.emptyRow', () => {
        test('ignore rows have every element is defaultValue', () => __awaiter(this, void 0, void 0, function* () {
            const input = `a	b	c	d
      1	2		3	4	
      					`;
            expect(parser_1.parser(input, Object.assign({}, defaultOptions, { separator: '\t', startColumn: 0, numberOfColumn: 4, defaultValue: null, ignoreRow: {
                    emptyRow: true
                } }))).toEqual([['a', 'b', 'c', 'd'], [1, 2, null, 3]]);
        }));
    });
});
